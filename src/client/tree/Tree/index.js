/* eslint-disable */

import React from 'react';
import PropTypes from 'prop-types';
import { TransitionGroup } from 'react-transition-group';
import { layout, select, behavior, event } from 'd3';
import clone from 'clone';
import deepEqual from 'deep-equal';
import uuid from 'uuid';

import Node from '../Node';
import Link from '../Link';
import './style.css';

import MapModel from '../../actions/maps';

const TreeObject = function(name, id){
  this.name = name;
  this.id = id;
  this.children = [];
};

// TreeObject.prototype.addChild = function(child){
//   this.children.push(child);
//   // return the new child node for convenience
//   return child;
// };

// TreeObject.prototype.removeChild = function(child){
//   var index = this.children.indexOf(child);
//   if(index !== -1){
//     // remove the child
//     this.children.splice(index,1);
//   }else{
//     throw new Error("That node is not an immediate child of this tree");
//   }
// };


export default class Tree extends React.Component {

  constructor(props) {
    // console.log(props)
    super(props);
    this.state = {
      initialRender: true,
      data: this.assignInternalProperties(clone(props.data)),
      // selectedNode:
      // sendData: []
      // sendData: this.createLocalSendData(clone(this.state.data))
      // selectedNode: 

    };
    this.findNodesById = this.findNodesById.bind(this);
    this.collapseNode = this.collapseNode.bind(this);
    this.handleOnClickCb = this.handleOnClickCb.bind(this);
    this.addNode = this.addNode.bind(this);
    this.removeNode = this.removeNode.bind(this);
    this.editNode = this.editNode.bind(this);
    this.resetSendData = this.resetSendData.bind(this);
    this.createLocalSendData = this.createLocalSendData.bind(this);
    this.handleOnClick = this.handleOnClick.bind(this);
    this.handleRightClick = this.handleRightClick.bind(this);
    this.handleTextChange = this.handleTextChange.bind(this);
    this.editMapHelper = this.editMapHelper.bind(this);
  }


  componentDidMount() {
    console.log('tree got rendered: ', this);
    // this.setState({
    //   sendData: this.createLocalSendData(clone(this.state.data[0]))
    // }, ()=>{ console.log(this.state.senData, 'check on sendData condition'); })
    // this.resetSendData();
    // console.log(this.state.senData, 'check on sendData condition');
    this.bindZoomListener(this.props);
    // TODO find better way of setting initialDepth, re-render here is suboptimal
    this.setState({ initialRender: false }); // eslint-disable-line
    // console.log('XXXXXhow many times did this render?XXXXX', this.state.data)
  }


  componentWillReceiveProps(nextProps) {
    // Clone new data & assign internal properties
    // console.log('console outside')
    // console.log('current: ', this.props.data, 'next: ', nextProps.data, 'XXXXXhow many times did this render?XXXXX')
    // if (!deepEqual(this.props.data, nextProps.data)) {
    // console.log(nextProps, 'whats this?')
    this.setState({
      data: this.assignInternalProperties(clone(nextProps.data)),
      // sendData: this.createLocalSendData(clone(this.state.data[0]))
    }, ()=> {this.resetSendData()});
    

    // If zoom-specific props change -> rebind listener with new values
    if (!deepEqual(this.props.translate, nextProps.translate)
    || !deepEqual(this.props.scaleExtent, nextProps.scaleExtent)) {
      // console.log('ran this one?')
      this.bindZoomListener(nextProps);
    }
  }

  resetSendData() {
    // console.log('how many times?', this.state.data[0])
    // console.log('inside of resetSendData: ', this.state.data[0])
    // console.log('what happen after createLocalSendData:', this.createLocalSendData(clone(this.state.data[0])))
    return this.createLocalSendData(clone(this.state.data[0]))
    // this.setState({
    //   sendData: this.createLocalSendData(clone(this.state.data[0]))
    // })
  }

  /**
   * setInitialTreeDepth - Description
   *
   * @param {array} nodeSet Array of nodes generated by `generateTree`
   * @param {number} initialDepth Maximum initial depth the tree should render
   *
   * @return {void}
   */
  setInitialTreeDepth(nodeSet, initialDepth) {
    nodeSet.forEach((n) => {
      n._collapsed = n.depth >= initialDepth;
    });
  }


  /**
   * bindZoomListener - If `props.zoomable`, binds a listener for
   * "zoom" events to the SVG and sets scaleExtent to min/max
   * specified in `props.scaleExtent`.
   *
   * @return {void}
   */
  bindZoomListener(props) {
    const { zoomable, scaleExtent, translate } = props;
    const svg = select('.rd3t-svg');
    const g = select('.rd3t-g');

    if (zoomable) {
      svg.call(behavior.zoom()
        .scaleExtent([scaleExtent.min, scaleExtent.max])
        .on('zoom', () => {
          g.attr('transform',
            `translate(${event.translate}) scale(${event.scale})`
          );
        })
        // Offset so that first pan and zoom does not jump back to [0,0] coords
        .translate([translate.x, translate.y])
      );
    }
  }


  /**
   * assignInternalProperties - Assigns internal properties to each node in the
   * `data` set that are required for tree manipulation and returns
   * a new `data` array.
   *
   * @param {array} data Hierarchical tree data
   *
   * @return {array} `data` array with internal properties added
   */
  assignInternalProperties(data) {
    return data.map((node) => {
      // console.log('each node in assignedInternalProps:', node)
      node.id = uuid.v4();
      // console.log(node.id, 'each nodes id');
      // console.log(node)
      node._collapsed = false;
      // if there are children, recursively assign properties to them too
      if (node.children && node.children.length > 0) {
        node.children = this.assignInternalProperties(node.children);
        node._children = node.children;
      }
      return node;
    });
  }


  /**
   * findNodesById - Description
   *
   * @param {string} nodeId The `node.id` being searched for
   * @param {array} nodeSet Array of `node` objects
   * @param {array} hits Accumulator for matches, passed between recursive calls
   *
   * @return {array} Set of nodes matching `nodeId`
   */
   // TODO Refactor this into a more readable/reasonable recursive depth-first walk.
  findNodesById(nodeId, nodeSet, hits) {
    if (hits.length > 0) {
      return hits;
    }

    hits = hits.concat(nodeSet.filter((node) => node.id === nodeId));

    nodeSet.forEach((node) => {
      if (node._children && node._children.length > 0) {
        hits = this.findNodesById(nodeId, node._children, hits);
        return hits;
      }
      return hits;
    });

    return hits;
  }


  /**
   * collapseNode - Recursively sets the `_collapsed` property of
   * the passed `node` object and its children to `true`.
   *
   * @param {object} node Node object with custom properties
   *
   * @return {void}
   */
  collapseNode(node) {
    node._collapsed = true;
    if (node._children && node._children.length > 0) {
      node._children.forEach((child) => {
        this.collapseNode(child);
      });
    }
  }


  /**
   * expandNode - Sets the `_collapsed` property of
   * the passed `node` object to `false`.
   *
   * @param {type} node Node object with custom properties
   *
   * @return {void}
   */
  expandNode(node) {
    node._collapsed = false;
  }


  /**
   * handleNodeToggle - Finds the node matching `nodeId` and
   * expands/collapses it, depending on the current state of
   * its `_collapsed` property.
   * `setState` callback receives targetNode and handles
   * `props.onClick` if defined.
   *
   * @param {string} nodeId A node object's `id` field.
   *
   * @return {void}
   */
  handleOnClick(nodeId) {
    // console.log('what would happen? would this thing break?', nodeId)
    // this.handleOnClickCb();

    const data = clone(this.state.data);
    const matches = this.findNodesById(nodeId, data, []);
    const targetNode = matches[0];

    this.addNode(targetNode, data);
    // console.log(targetNode)

    // setTimeout(()=>{console.log('tree props', this.props)}, 1000);
    // await MapModel.editMap(this.props.mapId, data);
    // this.props.updateMap();



    // if (this.props.collapsible) {
    //   targetNode._collapsed
    //     ? this.expandNode(targetNode)
    //     : this.collapseNode(targetNode);
    //   this.setState({ data }, () => this.handleOnClickCb(targetNode));
    // } else {
    //   this.handleOnClickCb(targetNode);
    // }
  }

  async editMapHelper() {
    await MapModel.editMap(this.props.mapId, this.resetSendData());
    this.props.updateMap();
  }
  
  handleRightClick(nodeId) {
    const data = clone(this.state.data);
    // const matches = this.findNodesById(nodeId, data, []);
    // const targetNode = matches[0];

    // this.removeNode(nodeId, data[0]);
    this.setState({
        data: this.assignInternalProperties(this.removeNode(nodeId, data[0]))
      }, async ()=>{
        await MapModel.editMap(this.props.mapId, this.resetSendData());
        this.props.updateMap();
      })
  }

  handleTextChange(nodeId) {
    const data = clone(this.state.data);
    this.setState({
      data: this.assignInternalProperties(this.editNode(nodeId, data[0]))
    }, this.editMapHelper)

  }


  createLocalSendData(data) {
    // console.log(data, '========')
    let newData = new TreeObject(data.name, data.id);
    let inner = function(data, newData) {
      if (data.children === undefined) {
        return;
      }
      for (let i = 0; i < data.children.length; i++) {
        // console.log('=========', data.children[i].id, '========')
        if (data.children[i].id) {
          newData.children.push(new TreeObject(data.children[i].name, data.children[i].id)); 
        } else {
          newData.children.push(new TreeObject(data.children[i].name));
        }
        inner(data.children[i], newData.children[i]);
      }
    }
    inner(data, newData);
    // console.log(newData, '----didthiscomeoutright')
    return [newData];
  }

  addNode(targetNode, data) {
    if (targetNode.children) {
      console.log('whats the targetNode:', targetNode)
      targetNode.children.push({name: 'new node', children: []});

      // console.log('target node=========',targetNode)
      // console.log('tree data====', data)
      // console.log('sendData state: ', this.state.sendData)
      // console.log('data state: ', this.state.data)
      this.setState({
        data: this.assignInternalProperties(clone(data))
      }, this.editMapHelper)
    } else {
      targetNode.children = [{name: 'new node', children:[]}];
      // console.log('targetNode.children: ', targetNode.children)
      // console.log('targetnode :', targetNode);
      // console.log('tree data', data);
      // console.log('data state in node has no children: ', this.state.data)
      this.setState({
        data: this.assignInternalProperties(clone(data))
      }, this.editMapHelper)
    }
  }

  removeNode(nodeId, data) {
    if (data.id === nodeId) {
      console.log('can not remove original node')
      return [data];
    }
    console.log(data.id, '???')
    if (data.children) {   
      for (let i = 0; i < data.children.length; i++ ) {
        if (data.children[i].id === nodeId) {
          data.children.splice(i, 1);
          return [data]
        }
        this.removeNode(nodeId, data.children[i])
      }
    }
    return [data];

  }

  editNode(nodeId) {


  }


  // strippingData(data) {
  //   let Tree = function(value) {
  //     this.value = value;
  //     this.children = [];
  //   }
  //   newData = [];
  //   newTree = {};
    
  //   let recursion = function(data, newTree) {
  //     newTree.name = data.name;
  //     newTree.children = [];
  //     for (let child of data.children) {
  //       newTree.children.push({})
  //       recursion(child, newTree.children)
  //     }

  //   }
  //   recursion(data, newTree);
  //   newData.push(newTree);

  //   return newData;
  // }


  /**
   * handleOnClickCb - Handles the user-defined `onClick` function
   *
   * @param {object} targetNode Description
   *
   * @return {void}
   */
  handleOnClickCb(targetNode) {
    console.log(targetNode)
    const { onClick } = this.props;
    if (onClick && typeof onClick === 'function') {
      onClick(clone(targetNode));
    }
  }


  /**
   * generateTree - Generates tree elements (`nodes` and `links`) by
   * grabbing the rootNode from `this.state.data[0]`.
   * Restricts tree depth to `props.initialDepth` if defined and if this is
   * the initial render of the tree.
   *
   * @return {object} Object containing `nodes` and `links`.
   */
  generateTree() {
    const {
      initialDepth,
      depthFactor,
      separation,
      nodeSize,
      orientation,
    } = this.props;

    const tree = layout.tree()
      .nodeSize(orientation === 'horizontal' ?
        [nodeSize.y, nodeSize.x] :
        [nodeSize.x, nodeSize.y]
      )
      .separation((a, b) => deepEqual(a.parent, b.parent) ?
        separation.siblings :
        separation.nonSiblings
      )
      .children((d) => d._collapsed ? null : d._children);

    const rootNode = this.state.data[0];
    const nodes = tree.nodes(rootNode);
    const links = tree.links(nodes);

    // set `initialDepth` on first render if specified
    if (initialDepth !== undefined && this.state.initialRender) {
      this.setInitialTreeDepth(nodes, initialDepth);
    }

    if (depthFactor) {
      nodes.forEach((node) => { node.y = node.depth * depthFactor; });
    }

    return { nodes, links };

  }

  render() {
    const { nodes, links } = this.generateTree();
    const {
      orientation,
      translate,
      pathFunc,
      transitionDuration,
      zoomable,
      circleRadius,
      styles,
    } = this.props;


    return (
      <div className={`rd3t-tree-container ${zoomable ? 'rd3t-grabbable' : undefined}`}>
        <svg className="rd3t-svg" width="100%" height="100%">
          <g
            className="rd3t-g"
            transform={`translate(${translate.x},${translate.y})`}
          >
          {links.map((linkData) =>
            <Link
              key={uuid.v4()}
              orientation={orientation}
              pathFunc={pathFunc}
              linkData={linkData}
              transitionDuration={transitionDuration}
              styles={styles.links}
            />
          )}
          {nodes.map((nodeData) => {
            // console.log("nodeData:", nodeData)
            return (
              <Node
                key={nodeData.id}
                orientation={orientation}
                transitionDuration={transitionDuration}
                textAnchor="start"
                nodeData={nodeData}
                name={nodeData.name}
                attributes={nodeData.attributes}
                onClick={this.handleOnClick}
                onRightClick={this.handleRightClick}
                onTextClick={this.handleTextClick}
                circleRadius={circleRadius}
                styles={styles.nodes}
              />
            )
          })}
          </g>
          
        </svg>
      </div>
    );
  }
}

Tree.defaultProps = {
  onClick: undefined,
  orientation: 'horizontal',
  translate: { x: 200, y: 375 },
  pathFunc: 'elbow',
  // translate: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
  // pathFunc: 'diagonal',
  transitionDuration: 500,
  depthFactor: undefined,
  collapsible: true,
  initialDepth: 150,
  zoomable: true,
  scaleExtent: { min: 0.1, max: 1 },
  nodeSize: { x: 150, y: 150 },
  separation: { siblings: 1, nonSiblings: 2 },
  circleRadius: 7,
  styles: {},
};

Tree.propTypes = {
  data: PropTypes.array.isRequired,
  onClick: PropTypes.func,
  orientation: PropTypes.oneOf([
    'horizontal',
    'vertical',
  ]),
  translate: PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number,
  }),
  pathFunc: PropTypes.oneOf([
    'diagonal',
    'elbow',
    'straight',
  ]),
  transitionDuration: PropTypes.number,
  depthFactor: PropTypes.number,
  collapsible: PropTypes.bool,
  initialDepth: PropTypes.number,
  zoomable: PropTypes.bool,
  scaleExtent: PropTypes.shape({
    min: PropTypes.number,
    max: PropTypes.number,
  }),
  nodeSize: PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number,
  }),
  separation: PropTypes.shape({
    siblings: PropTypes.number,
    nonSiblings: PropTypes.number,
  }),
  circleRadius: PropTypes.number,
  styles: PropTypes.shape({
    nodes: PropTypes.object,
    links: PropTypes.object,
  }),
};
